/*	Z80 Emulator: ED instruction handlers	Copyright (C) 1995 G.Woigk		This file is part of Mac Spectacle and it is free software	See application.c for details				This program is distributed in the hope that it will be useful,	but WITHOUT ANY WARRANTY; without even the implied warranty of	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  	based on fMSX; Copyright (C) Marat Fayzullin 1994,1995	All opcodes covered, no unsupported opcodes!*/increment_r;COUNT_ED_INSTR;switch(n){case ADC_HL_BC: time(15); M_ADCW(BC); loop;case ADC_HL_DE: time(15); M_ADCW(DE); loop;case ADC_HL_HL: time(15); M_ADCW(HL); loop;case ADC_HL_SP: time(15); M_ADCW(sp); loop;case SBC_HL_BC: time(15); M_SBCW(BC); loop;case SBC_HL_DE: time(15); M_SBCW(DE); loop;case SBC_HL_HL: time(15); M_SBCW(HL); loop;case SBC_HL_SP: time(15); M_SBCW(sp); loop;case LD_xWORDe_BC:	time(20); w = nn; poke2(w,BC);	loop;case LD_xWORDe_DE:	time(20); w = nn; poke2(w,DE);	loop;case LD_xWORDe_HL:	time(20); w = nn; poke2(w,HL);	loop;case LD_xWORDe_SP:	time(20); w = nn; poke2(w,sp);	loop;case LD_BC_xWORDe:	time(20); w = nn; RC = peek(w); RB = peek(w+1);	loop;case LD_DE_xWORDe:	time(20); w = nn; RE = peek(w); RD = peek(w+1);	loop;case LD_HL_xWORDe:	time(20); w = nn; RL = peek(w); RH = peek(w+1);	loop;case LD_SP_xWORDe:	time(20); w = nn; sp = peek(w) + ((UInt16)peek(w+1)<<8);	loop;case IN_B_xC:  time(12); sto_cc; M_IN(RB); loop;case IN_C_xC:  time(12); sto_cc; M_IN(RC); loop;case IN_D_xC:  time(12); sto_cc; M_IN(RD); loop;case IN_E_xC:  time(12); sto_cc; M_IN(RE); loop;case IN_H_xC:  time(12); sto_cc; M_IN(RH); loop;case IN_L_xC:  time(12); sto_cc; M_IN(RL); loop;case IN_A_xC:  time(12); sto_cc; M_IN(ra); loop;case IN_F_xC:  time(12); sto_cc; M_IN(c);  loop;case OUT_xC_B: time(12); sto_cc; Do_Output(BC,RB); loop;case OUT_xC_C: time(12); sto_cc; Do_Output(BC,RC); loop;case OUT_xC_D: time(12); sto_cc; Do_Output(BC,RD); loop;case OUT_xC_E: time(12); sto_cc; Do_Output(BC,RE); loop;case OUT_xC_H: time(12); sto_cc; Do_Output(BC,RH); loop;case OUT_xC_L: time(12); sto_cc; Do_Output(BC,RL); loop;case OUT_xC_0: time(12); sto_cc; Do_Output(BC,0);	 loop_weird2;case OUT_xC_A: time(12); sto_cc; Do_Output(BC,ra); loop;case ED4E:case ED66:case ED6E:	info_misc2;time(8); IM=0; loop_weird2;	// illegal: im0case ED76:	info_misc2;time(8); IM=1; loop_weird2;	// illegal: im1case ED7E:	info_misc2;time(8); IM=2; loop_weird2;	// illegal: im2case ED4C:case ED54:case ED5C:case ED64:case ED6C:case ED74:case ED7C:	time(8); c=ra;ra=0;M_SUB(c);	loop_weird2;	// illegal NEGcase IM_0:	info_misc2;time(8); IM=0;	loop;case IM_1:	info_misc2;time(8); IM=1;	loop;case IM_2:	info_misc2;time(8); IM=2;	loop;case NEG:   time(8); c=ra;ra=0;M_SUB(c);	loop;case LD_I_A:   info_misc2;time(9);RI=ra;loop;case LD_R_A:   info_misc2;time(9); ld_r_a;	loop;case LD_A_I:	info_misc2;	time(9); 	ra	= RI;	rf	= (rf&C_FLAG) + (IFF2?P_FLAG:0) + (ra?0:Z_FLAG) + (ra&S_FLAG);	loop;case LD_A_R:	info_misc2;	time(9); 	ld_a_r;	rf	= (rf&C_FLAG) + (IFF2?P_FLAG:0) + (ra?0:Z_FLAG) + (ra&S_FLAG);	loop;case ED5D:	// illegal: reticase ED6D:case ED7D:	info_misc2;time(14); pc=pop(); loop_weird2;case ED55:	// illegal: retncase ED65:case ED75:	info_misc2;time(14); pc=pop(); IFF1=IFF2; loop_weird2;case RETI:	info_misc2;time(14); pc=pop(); loop;case RETN:	info_misc2;time(14); pc=pop(); IFF1=IFF2; loop;case RRD:	time(18); 	c	= (peek(HL)>>4) + (ra<<4);	ra	= (ra&0xF0) + (peek(HL)&0x0F);	rf	= (rf&C_FLAG) + zlog_flags[ra];	poke(HL,c);	loop;case RLD:	time(18); 	c 	= (peek(HL)<<4) + (ra&0x0F);	ra	= (ra&0xF0)+(peek(HL)>>4);	rf	= (rf&C_FLAG) + zlog_flags[ra];	poke(HL,c);	loop;case LDI:	time(16); 	rf &= ~(N_FLAG+H_FLAG+P_FLAG);	if (--BC) rf |= P_FLAG;	w=DE++; poke(w,peek(HL++));	loop;case LDD:	time(16); 	rf &= ~(N_FLAG+H_FLAG+P_FLAG);	if (--BC) rf |= P_FLAG;	w=DE--; poke(w,peek(HL--));	loop;case LDIR:	add_r(2*c-2);	time((UInt16)(BC-1)*21+16); 	do {		poke ( DE++, peek(HL++) );	} while(--BC);	rf &= ~(N_FLAG+H_FLAG+P_FLAG);	loop;	case LDDR:	add_r(2*c-2);	time((UInt16)(BC-1)*21+16); 	do { 		poke ( DE--, peek(HL--) );	} while(--BC);	rf &= ~(N_FLAG+H_FLAG+P_FLAG);	loop;case CPD:	c = peek(HL--); goto c1;case CPI:	c = peek(HL++);c1:	time(16); 	w	= ra-c;	rf	= (rf&C_FLAG) + (wl&S_FLAG) + (wl?0:Z_FLAG) + N_FLAG + 		  (--BC?P_FLAG:0) + ((ra^c^wl)&H_FLAG);	loop;case CPIR:	add_r(2*c-2);	time((UInt16)(BC-1)*21+16); 	do { c=peek(HL++); w=ra-c; --BC; } while(BC&&wl);	rf	= (rf&C_FLAG) + (wl&S_FLAG) + (wl?0:Z_FLAG) + N_FLAG + 		  (BC?P_FLAG:0) + ((ra^c^wl)&H_FLAG);	more(-21*BC); 	add_r(-2*c);	loop;  case CPDR:	add_r(2*c-2);	time((UInt16)(BC-1)*21+16); 	do { c=peek(HL--); w=ra-c; --BC; } while(BC&&wl);	rf	= (rf&C_FLAG) + (wl&S_FLAG) + (wl?0:Z_FLAG) + N_FLAG + 		  (BC?P_FLAG:0) + ((ra^c^wl)&H_FLAG);	more(-21*BC); 	add_r(-2*c);	loop;case IND:	w = HL--; goto i1;case INI:	w = HL++;i1:	time(16);	sto_cc; 	c  = Do_Input(BC);	rf = N_FLAG + (--RB ? 0:Z_FLAG);	poke(w,c);	loop;case INDR:	w = -1; goto i2;case INIR:	w = +1;i2:	add_r(2*c-2);	time(-5);	do {		more(21);		sto_cc; 		c = Do_Input(BC);		poke(HL,c);		HL += w;	} while(--RB);	rf = Z_FLAG + N_FLAG;	loop;case OUTD:	w = HL--; goto o1;case OUTI:	w = HL++;o1:	time(16); 	sto_cc; 	Do_Output(BC,peek(w));	rf = N_FLAG + (--RB ? 0:Z_FLAG);	loop;case OTDR:	w = -1; goto o2;case OTIR:	w = +1;o2:	add_r(2*c-2);	time(-5); 	do { more(21); sto_cc; Do_Output(BC,peek(HL)); HL+=w; } while(--RB);	rf = Z_FLAG + N_FLAG;	loop;default:	// ED77, ED7F, ED00-ED3F and ED80-EDFF except block instr	time(8);	loop_weird2;};