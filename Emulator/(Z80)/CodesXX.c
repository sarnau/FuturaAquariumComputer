/*	Z80 Emulator: ix/iy instruction handlers	Copyright (C) 1995 G.Woigk		This file is part of Mac Spectacle and it is free software	See application.c for details				This program is distributed in the hope that it will be useful,	but WITHOUT ANY WARRANTY; without even the implied warranty of	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  	based on fMSX; Copyright (C) Marat Fayzullin 1994,1995		Handler for ix/iy prefixed instructions	All opcodes covered, no unsupported opcodes!*/increment_r;		// prefixed instructions increment r by 2COUNT_XY_INSTR;		// profilingswitch(n){case LD_H_B:	time(8);  rzh=RB; 					loop_ill2;case LD_L_B:   	time(8);  rzl=RB;					loop_ill2;case LD_X_B:	time(19); w=iz+dis; poke(w,RB);	loop;case LD_H_C:	time(8);  rzh=RC;					loop_ill2;case LD_L_C:	time(8);  rzl=RC;					loop_ill2;case LD_X_C:	time(19); w=iz+dis; poke(w,RC);	loop;case LD_H_D:	time(8);  rzh=RD;					loop_ill2;case LD_L_D:	time(8);  rzl=RD;					loop_ill2;case LD_X_D:	time(19); w=iz+dis; poke(w,RD);	loop;case LD_H_E:	time(8);  rzh=RE;					loop_ill2;case LD_L_E:	time(8);  rzl=RE;					loop_ill2;case LD_X_E:	time(19); w=iz+dis; poke(w,RE);	loop;case LD_B_H:	time(8);  RB=rzh;					loop_ill2;case LD_C_H:	time(8);  RC=rzh;					loop_ill2;case LD_D_H:	time(8);  RD=rzh;					loop_ill2;case LD_E_H:	time(8);  RE=rzh;					loop_ill2;case LD_H_H:	time(8);  rzh=rzh;					loop_weird2;case LD_L_H:	time(8);  rzl=rzh;					loop_weird2;case LD_A_H:	time(8);  ra=rzh;					loop_ill2;case LD_X_H:	time(19); w=iz+dis; poke(w,RH);	loop;case LD_B_L:	time(8);  RB=rzl;					loop_ill2;case LD_C_L:	time(8);  RC=rzl;					loop_ill2;case LD_D_L:	time(8);  RD=rzl;					loop_ill2;case LD_E_L:	time(8);  RE=rzl;					loop_ill2;case LD_H_L:	time(8);  rzh=rzl;					loop_weird2;case LD_L_L:	time(8);  rzl=rzl;					loop_weird2;case LD_A_L:	time(8);  ra=rzl;					loop_ill2;case LD_X_L:	time(19); w=iz+dis; poke(w,RL);	loop;case LD_H_A:	time(8);  rzh=ra;					loop_ill2;case LD_L_A:	time(8);  rzl=ra;					loop_ill2;case LD_X_A:	time(19); w=iz+dis; poke(w,ra);	loop;case LD_B_X:	time(19); RB=peek(iz+dis); 			loop;case LD_C_X:	time(19); RC=peek(iz+dis); 			loop;case LD_D_X:	time(19); RD=peek(iz+dis); 			loop;case LD_E_X:	time(19); RE=peek(iz+dis); 			loop;case LD_H_X:	time(19); RH=peek(iz+dis); 			loop;case LD_L_X:	time(19); RL=peek(iz+dis); 			loop;case LD_A_X:	time(19); ra=peek(iz+dis); 			loop;case LD_H_N:	time(11); rzh=n; 					loop_ill3;case LD_L_N:	time(11); rzl=n; 					loop_ill3;case LD_X_N:	time(19); w=iz+dis;c=n;poke(w,c);loop;case LD_xNN_HL:	time(20); w=nn; poke2(w,iz);		loop;case LD_HL_xNN:	time(20); w=nn; rzl=peek(w); rzh=peek(w+1);	loop;case EX_HL_xSP:	time(23); w=pop(); push(iz); iz=w;	loop;case PUSH_HL:	time(15); push(iz);					loop;case POP_HL:	time(14); iz=pop();					loop;case LD_HL_WORD:time(14); iz=nn;					loop;case LD_PC_HL:	time(8);  pc=iz;					loop;case LD_SP_HL:	time(10); sp=iz;					loop;case ADD_HL_BC:	time(15); M_ADDW(iz,BC);			loop;case ADD_HL_DE:	time(15); M_ADDW(iz,DE);			loop;case ADD_HL_HL:	time(15); M_ADDW(iz,iz);			loop;case ADD_HL_SP:	time(15); M_ADDW(iz,sp);			loop;case DEC_HL:   	time(10); iz--;						loop;case INC_HL:	time(10); iz++;						loop;case DEC_H:	time(8);  M_DEC(rzh);					loop_ill2;case DEC_L:	time(8);  M_DEC(rzl);					loop_ill2;case DEC_X:	time(23); w=iz+dis;c=peek(w);M_DEC(c);poke(w,c); loop;case INC_H:	time(8);  M_INC(rzh);					loop_ill2;case INC_L:	time(8);  M_INC(rzl);					loop_ill2;case INC_X:	time(23); w=iz+dis;c=peek(w);M_INC(c);poke(w,c); loop;case ADD_H:	time(8);  M_ADD(rzh);					loop_ill2;case ADD_L:	time(8);  M_ADD(rzl);					loop_ill2;case ADD_X:	time(19); c=peek(iz+dis); M_ADD(c);		loop;case SUB_H:	time(8);  M_SUB(rzh);					loop_ill2;case SUB_L:	time(8);  M_SUB(rzl);					loop_ill2;case SUB_X:	time(19); c=peek(iz+dis); M_SUB(c);		loop;case ADC_H:	time(8);  M_ADC(rzh);					loop_ill2;case ADC_L:	time(8);  M_ADC(rzl);					loop_ill2;case ADC_X:	time(19); c=peek(iz+dis); M_ADC(c);		loop;case SBC_H:	time(8);  M_SBC(rzh);					loop_ill2;case SBC_L:	time(8);  M_SBC(rzl);					loop_ill2;case SBC_X:	time(19); c=peek(iz+dis); M_SBC(c);		loop;case CP_H:	time(8);  M_CP(rzh);					loop_ill2;case CP_L:	time(8);  M_CP(rzl);					loop_ill2;case CP_X:	time(19); c=peek(iz+dis); M_CP(c);		loop;               case AND_H:	time(8);  M_AND(rzh);					loop_ill2;case AND_L:	time(8);  M_AND(rzl);					loop_ill2;case AND_X:	time(19); c=peek(iz+dis); M_AND(c);		loop;case OR_H:	time(8);  M_OR(rzh);					loop_ill2;case OR_L:	time(8);  M_OR(rzl);					loop_ill2;case OR_X:	time(19); c=peek(iz+dis); M_OR(c);		loop;case XOR_H:	time(8);  M_XOR(rzh);					loop_ill2;case XOR_L:	time(8);  M_XOR(rzl);					loop_ill2;case XOR_X:	time(19); c=peek(iz+dis); M_XOR(c);		loop;case PFX_CB://	Within an 8-instruction block, every illegal DD CB instruction works as//	the official one, but also copies the result to the specified register.	//	((The information about the inofficial CB instructions was given to   ))//	((Gerton Lunter by Arnt Gulbrandsen, and originated from David Librik.))	{	int o;	COUNT_XYCB_INSTR;	// profiling	time(20);			// SHIFT, SET, and RES: 23 T cycles; BIT: 20 T cycles		w = iz + dis;		// target address	c = peek(w);		// target	o = n;				// opcode		switch (o>>3)		// instruction	{	case RLC_X>>3:	M_RLC(c); break;	case RRC_X>>3:	M_RRC(c); break;	case RL_X>>3:	M_RL(c);  break;	case RR_X>>3:	M_RR(c);  break;	case SLA_X>>3:  M_SLA(c); break;	case SRA_X>>3:  M_SRA(c); break;	case SLL_X>>3:  M_SLL(c); break;	case SRL_X>>3:	M_SRL(c); break;	case BIT0_X>>3: M_BIT(0x01,c); break;	case BIT1_X>>3: M_BIT(0x02,c); break;	case BIT2_X>>3: M_BIT(0x04,c); break;	case BIT3_X>>3: M_BIT(0x08,c); break;	case BIT4_X>>3: M_BIT(0x10,c); break;	case BIT5_X>>3: M_BIT(0x20,c); break;	case BIT6_X>>3: M_BIT(0x40,c); break;	case BIT7_X>>3: M_BIT(0x80,c); break;		case RES0_X>>3:	c &= ~0x01; break;	case RES1_X>>3: c &= ~0x02; break;	case RES2_X>>3: c &= ~0x04; break;	case RES3_X>>3: c &= ~0x08; break;	case RES4_X>>3: c &= ~0x10; break;	case RES5_X>>3: c &= ~0x20; break;	case RES6_X>>3: c &= ~0x40; break;	case RES7_X>>3: c &= ~0x80; break;	case SET0_X>>3: c |= 0x01;  break;	case SET1_X>>3: c |= 0x02;  break;	case SET2_X>>3: c |= 0x04;  break; 	case SET3_X>>3: c |= 0x08;  break; 	case SET4_X>>3: c |= 0x10;  break; 	case SET5_X>>3: c |= 0x20;  break; 	case SET6_X>>3: c |= 0x40;  break; 	case SET7_X>>3: c |= 0x80;  break; 	};	switch(o&0x07)	// copy result to register (illegal opcodes only)	{	case 0:	RB=c; break;	case 1:	RC=c; break;	case 2:	RD=c; break;	case 3:	RE=c; break;	case 4:	RH=c; break;	case 5:	RL=c; break;	case 6:			if ( (o&0xc0)==0x40 ) loop;   // quick exit: legal bit test		more(3);poke(w,c);#if INFO_ILLEGALS		if ((o>>3)!=(SLL_X>>3)) loop; // quick exit: legal shift, set, res		loop_ill4;					  // SLL#else		loop;#endif	case 7:	ra=c; break;	};	if ((o&0xc0)==0x40) loop_weird4;		// illegal bit test	more(3);poke(w,c);	loop_weird4;							// illegal shift, set, res	};default:			// ix/iy prefix has no effect on operation:	time(4);		// T cycles for useless ix/iy prefix	decrement_r;	// r register only incremented by 1	--pc;			// execute instruction without prefix	loop_weird2;		// weird illegal};loop;	// never used